---
globs: app/**/*.php,tests/**/*.php
alwaysApply: false
---

## Architecture Rules

- **PHP:** PSR-12, strict types, PHP 8.x features (unions, match, attributes, readonly)
- **Imports:** Always add `use` statements instead of fully qualified class names
- **Type Safety:** All methods must have explicit return types with proper generics (e.g., `Collection<int, User>`)

**üö® Architecture rules are IMMUTABLE - fix violating code, not the architecture rules**

### Symfony Patterns

- **Dependency Injection:** instead of manually resolving and instantiating classes
- **Symfony Classes:** instead of native PHP functions for easier mocking during testing (eg. `Filesystem::`, `Process::`, etc.)

## Dependency Injection System

Use `App::build(ClassName::class)` for all object creation instead of `new ClassName()`.

**Core Flow:**

```php
// ‚úÖ CORRECT - Auto-wires dependencies
$service = App::build(MyService::class);
$command = App::build(HelloCommand::class);

// ‚ùå WRONG - Manual instantiation breaks DI
$service = new MyService(new Dependency());
```

**How It Works:**

1. `App::build()` delegates to singleton [Container](mdc:app/Container.php)
2. Container uses reflection to analyze constructor parameters
3. Recursively builds all dependencies automatically
4. Caches reflection data for performance
5. Handles circular dependencies and error cases

**Integration Points:**

- Entry point: [bin/deployer](mdc:bin/deployer) ‚Üí `App::run()`
- Command registration: [Deployer.php](mdc:app/Deployer.php) ‚Üí `App::build(HelloCommand::class)`
- Services: Auto-inject dependencies like `Filesystem`, `EnvService` via constructor

**Key Benefits:**

- Zero configuration - pure PHP reflection
- Type-safe with generics support
- Automatic error detection and meaningful messages
- Easy testing with mockable dependencies
- No manual dependency wiring required

**Rule:** ALL object creation must use `App::build()` except for value objects, DTOs, and pure data structures.

**Testing Exception:** Direct `Container` instantiation is acceptable in tests to isolate state and avoid shared singleton behavior. Production code must always use `App::build()`.

```php
// ‚úÖ ACCEPTABLE IN TESTS - Isolated container for test isolation
$container = new Container();
$service = $container->build(TestService::class);

// ‚úÖ PRODUCTION CODE - Use singleton container via App
$service = App::build(TestService::class);
```

### Command Layer

- Commands handle user interaction (input/output) and orchestrate Services
- Commands must NOT contain business logic - delegate to Services
- Commands must NOT duplicate orchestration logic - extract to shared Services
- Commands are responsible for console styling, error formatting, and user prompts
- Commands should not invoke other commands - NO proxy commands

### Service Layer (Business Logic)

- Services provide atomic, reusable functionality with no console I/O
- Services accept plain PHP data types and return plain PHP data types
- Services must be stateless and dependency-injected
- Services handle core business logic, external API calls, file operations
- Complex orchestration shared by multiple Commands should be extracted to dedicated Services

### Console I/O Rules

- Only Commands perform console input/output operations
- Use SymfonyStyle consistently for all user-facing output
- Services return exceptions or structured data for Commands to handle
- Validation errors and business exceptions bubble up to Commands for display

### Dependency Rules

- Commands depend on Services
- Services depend on other Services or utilities
- All dependencies declared in constructor signatures

**IMPORTANT:** No circular dependencies allowed.

### Comments

**DocBlock:** Add docblock comments with minimalist descriptions, parameters and return types for classes and functions;

**Comment everything:** Use comments to separate sections and explain or summarize complex logic;

```
//
// {Section Header}
// -------------------------------------------------------------------------------

//
// {Section Subheader}

// {Paragraph}
```

- Use comments as visual separators to help separate different sections
- Separate section headers, subheaders and paragraphs with a single newline
- Avoid commenting the obvious or leaving comments behind when removing code

**ALWAYS use the correct section header comment format and not the simplified one:**

```
    //
    // {Section Header}
    // ---- ‚ùå Too few dashes
```

### Quality Gates

**ALWAYS run these commands against the files you have touched and fix any issues BEFORE considering a task complete:**

```bash
vendor/bin/rector $CHANGED_PHP_FILES  # Code improvements (changed files only)
vendor/bin/pint $CHANGED_PHP_FILES    # Fix code style (changed files only)

# Static analysis excluding tests (never do static analysis against tests)
vendor/bin/phpstan analyze $CHANGED_PHP_FILES_EXCEPT_TESTS
```
