---
alwaysApply: true
---

## Architecture Rules

- **PHP:** PSR-12, strict types, PHP 8.x features (unions, match, attributes, readonly)
- **Imports:** Always add `use` statements instead of fully qualified class names
- **Type Safety:** All methods must have explicit return types with proper generics (e.g., `Collection<int, User>`)

**🚨 Architecture rules are IMMUTABLE - fix violating code, not the architecture rules**

### Symfony Patterns

- **Dependency Injection:** instead of manually resolving and instantiating classes
- **Symfony Classes:** instead of native PHP functions for easier mocking during testing (eg. `Filesystem::`, `Process::`, etc.)

## Dependency Injection System

Use `$container->build(ClassName::class)` for all object creation instead of `new ClassName()`.

**Core Flow:**

```php
// ✅ CORRECT - Auto-wires dependencies via injected container
$service = $this->container->build(MyService::class);
$command = $container->build(HelloCommand::class);

// ❌ WRONG - Manual instantiation breaks DI
$service = new MyService(new Dependency());
```

**How It Works:**

1. `Container->build()` uses reflection to analyze constructor parameters
2. Recursively builds all dependencies automatically
3. Caches reflection data for performance
4. Handles circular dependencies and error cases

**Integration Points:**

- Entry point: [bin/deployer](mdc:bin/deployer) → Direct container instantiation and `$app->run()`
- Command registration: [SymfonyApp.php](mdc:app/SymfonyApp.php) → `$this->container->build(HelloCommand::class)`
- Services: Auto-inject dependencies like `Filesystem`, `EnvService` via constructor

**Key Benefits:**

- Zero configuration - pure PHP reflection
- Type-safe with generics support
- Automatic error detection and meaningful messages
- Easy testing with mockable dependencies
- No manual dependency wiring required

**Rule:** ALL object creation must use `$container->build()` except for value objects, DTOs, and pure data structures.

**Container Access:** In production code, access the container through constructor injection.

```php
// ✅ PRODUCTION CODE - Container injected via DI
class SymfonyApp {
    public function __construct(private readonly Container $container) { ... }

    private function registerCommands(): void {
        $command = $this->container->build(HelloCommand::class);
    }
}

// ✅ TESTS - Direct container instantiation for isolation
$container = new Container();
$service = $container->build(TestService::class);
```

### Command Layer

- Commands handle user interaction (input/output) and orchestrate Services
- Commands must NOT contain business logic - delegate to Services
- Commands must NOT duplicate orchestration logic - extract to shared Services
- Commands are responsible for console styling, error formatting, and user prompts
- Commands should not invoke other commands - NO proxy commands

### Service Layer (Business Logic)

- Services provide atomic, reusable functionality with no console I/O
- Services accept plain PHP data types and return plain PHP data types
- Services must be dependency-injected via constructor
- Services handle core business logic, external API calls, file operations
- Complex orchestration shared by multiple Commands should be extracted to dedicated Services

**Service State:**

- **Stateless Services:** Pure operations with no internal state (e.g., validators, calculators, API clients)
- **Stateful Services:** Services that manage configuration or cached data (e.g., config loaders, file managers, repositories)
- Stateful services should use lazy loading when initialization is expensive or path-dependent
- State must be initialized explicitly via public methods before use (e.g., `load()`, `initialize()`)
- Services should document their stateful nature and initialization requirements

### Console I/O Rules

- Only Commands perform console input/output operations
- Use SymfonyStyle consistently for all user-facing output
- Services return exceptions or structured data for Commands to handle
- Validation errors and business exceptions bubble up to Commands for display

### Dependency Rules

- Commands depend on Services
- Services depend on other Services or utilities
- All dependencies declared in constructor signatures

**IMPORTANT:** No circular dependencies allowed.

### Comments

**DocBlock:** Add docblock comments with minimalist descriptions, parameters and return types for classes and functions;

**Comment everything:** Use comments to separate sections and explain or summarize complex logic;

```
//
// {Section Header}
// -------------------------------------------------------------------------------

//
// {Section Subheader}

// {Paragraph}
```

- Use comments as visual separators to help separate different sections
- Separate section headers, subheaders and paragraphs with a single newline
- Avoid commenting the obvious or leaving comments behind when removing code

### Quality Gates

**ALWAYS run these commands against the files you have touched and fix any issues BEFORE considering a task complete:**

```bash
vendor/bin/rector $CHANGED_PHP_FILES  # Code improvements (changed files only)
vendor/bin/pint $CHANGED_PHP_FILES    # Fix code style (changed files only)

# Static analysis excluding tests (never do static analysis against tests)
vendor/bin/phpstan analyze $CHANGED_PHP_FILES_EXCEPT_TESTS
```
